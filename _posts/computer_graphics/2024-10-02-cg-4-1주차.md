---
title: "(OpenGL) Shading Language(GLSL)"
excerpt: ""

categories:
  - Computer Graphics
tags:
  - [tag1, tag2]

permalink: /categories/computer_graphics/shading_language/

toc: true
toc_sticky: true

date: 2024-10-02
last_modified_at: 2024-10-02
---

## 🦥 Shading Language(GLSL)

vshader
정점 하나당 vshader의 main 실행됨
들어오는 점 하나하나를 화면상의 좌표로 변환하는 역할
가운데가 (0,0) 기준으로 점을 변환해야함
gl_Position - 미리 정의된 변수에 값을 하나씩 가져와서 처리
gl_Position = vec4(0,0,0,1);


fshader
픽셀 하나당 fshader의 main 실행됨
해당 픽셀에 해당하는 fragment에 의한 색상 값을 out vec4 fColor로 반환

함수의 인자와 반환을 in, out 키워드로 따로 설정



vshader
```
#version 330

in vec4 vPosition;
in vec4 vColor;

out vec4 color;

void main()
{
	gl_Position = vPosition;
	color = vColor;
}
```


fshader
```
#version 330

in vec4 color;
out vec4 fColor;

void main()
{
	fColor = color;
}
```


main
```
#include <vgl.h>
#include <InitShader.h>
#include <vec.h>

vec4 vertex_pos[8] = {
	vec4(-0.5,-0.5, 0.5, 1),
	vec4(-0.5, 0.5, 0.5, 1),
	vec4(0.5, 0.5, 0.5, 1),
	vec4(0.5,-0.5, 0.5, 1),
	vec4(-0.5,-0.5,-0.5, 1),
	vec4(-0.5, 0.5,-0.5, 1),
	vec4(0.5, 0.5, -0.5, 1),
	vec4(0.5,-0.5, -0.5, 1)
};

vec4 vertex_color[8] = {
	vec4(1,0,0,1),
	vec4(0,1,0,1),
	vec4(0,0,1,1),
	vec4(1,1,0,1),
	vec4(0,1,1,1),
	vec4(1,0,1,1),
	vec4(1,1,1,1),
	vec4(0,0,0,1)
};

const int NumVertex = 6 * 2 * 3;
vec4 positions[NumVertex];
vec4 colors[NumVertex];


void makeRect(int a, int b, int c, int d)
{
	static int cur = 0;
	positions[cur] = vertex_pos[a];	colors[cur] = vertex_color[a]; cur++;
	positions[cur] = vertex_pos[b];	colors[cur] = vertex_color[b]; cur++;
	positions[cur] = vertex_pos[c];	colors[cur] = vertex_color[c]; cur++;

	positions[cur] = vertex_pos[c];	colors[cur] = vertex_color[c]; cur++;
	positions[cur] = vertex_pos[d];	colors[cur] = vertex_color[d]; cur++;
	positions[cur] = vertex_pos[a];	colors[cur] = vertex_color[a]; cur++;
}



void makeCube()
{
	// 시계 반대방향으로 꼭짓점 해석 (삼각형 만들 때)
	makeRect(0, 3, 2, 1);
	makeRect(4, 5, 6, 7);
	makeRect(0, 4, 7, 3);
	makeRect(3, 7, 6, 2);
	makeRect(2, 6, 5, 1);
	makeRect(1, 5, 4, 0);
	
}

void myInit()
{
	// Create data in CPU
	makeCube();

	// Send data to GPU
	//1. Setup VAO (gen and bind)
	GLuint vao;
	glGenVertexArrays(1, &vao);
	glBindVertexArray(vao);

	//2. Setup VBO (gen and bind)
	GLuint vbo;
	glGenBuffers(1, &vbo);
	glBindBuffer(GL_ARRAY_BUFFER, vbo);

	//3. Copy data to Buffer
	// 세번 째 인자 NULL하면 아직 데이터는 안보내고 메모리만 동적할당 됨
	glBufferData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(colors), NULL, GL_STATIC_DRAW);
	// 위치 데이터를 잡힌 메모리에 처음부터 집어넣음
	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), positions);
	// 색상 데이터를 메모리에 2번째 인자 위치부터 집어넣음
	glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(colors), colors);
	// 따라서 앞 부분은 위치 데이터, 뒷 부분은 색상 데이터를 밀어넣음
	
	
	//4. Load Shaders
	// 셰이더가 로드 되고 로딩된 셰이더에 대한 핸들을 받아옴
	GLuint prog = InitShader("vshader.glsl", "fshader.glsl");
	// 셰이더 사용
	glUseProgram(prog);
	

	//5. Connect shader to buffer
	// 셰이더와 데이터를 연결하는 과정
	// 메모리 앞의 위치한 데이터와 메모리 뒤에 위치한 색상 데이터를 셰이더가 어떻게 해석할건지 알려줘야함
	
	// vPosition
	// "내가 아까 보낸 vPosition 변수가 셰이더에 있을거야" -> 변수를 지칭하는 핸들 반환
	GLuint vPosition = glGetAttribLocation(prog, "vPosition");
	// "그 변수 내가 지금 보내줄거야" -> 셰이더에 in 으로 들어옴
	glEnableVertexAttribArray(vPosition);
	// "4개의 float 변수로 되어있을거고, 아까 보낸 데이터의 처음부터(BUFFER_OFFSET(0)) 시작해서 연속해서 있을거야"
	glVertexAttribPointer(vPosition, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

	// vColor
	GLuint vColor = glGetAttribLocation(prog, "vColor");
	glEnableVertexAttribArray(vColor);
	// "4개의 float 변수로 되어있을거고, 아까 보낸 데이터의 sizeof(positions) 이후부터 시작해서 연속해서 있을거야"
	glVertexAttribPointer(vColor, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(sizeof(positions)));
	

	// 4번째 인자(GL_FALSE)는 예를들어 vector를 보낼 때 크기를 1로 만들어주는 nomarlize를 쓸지 말지 정하는 그런 기능
}

void myDisplay()
{
	glClear(GL_COLOR_BUFFER_BIT);
	//현재 바인딩된 Array를 현재 바인딩된 shader program으로 화면에 그림
	glDrawArrays(GL_TRIANGLES, 0, NumVertex);
	glFlush();
}

int main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);
	glutInitWindowSize(512, 512);
	glutCreateWindow("Color Cube Example");

	glewExperimental = true;
	glewInit();

	myInit();

	glutDisplayFunc(myDisplay);
	glutMainLoop();

	return 0;
}

```


위 결과로 z축으로 바라본 2차원 정사각형으로 보임

카메라를 회전하지 않고 vshader에서 물체를 행렬을 곱해 회전시킬 수 있음
-> 앞으로 이런 과정을 shader를 배우면서 학습할 예정


glsl은 c와 비슷하지만 포인터, 동적할당 등의 복잡한 기능이 없고,
수학 관련된 기능이 많이 들어있음

