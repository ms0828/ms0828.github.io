---
title: "(OpenGL) Shading Language(GLSL)"
excerpt: ""

categories:
  - Computer Graphics
tags:
  - [tag1, tag2]

permalink: /categories/computer_graphics/shading_language/

toc: true
toc_sticky: true

date: 2024-10-02
last_modified_at: 2024-10-02
---

## ğŸ¦¥ Shading Language(GLSL)

vshader
ì •ì  í•˜ë‚˜ë‹¹ vshaderì˜ main ì‹¤í–‰ë¨
ë“¤ì–´ì˜¤ëŠ” ì  í•˜ë‚˜í•˜ë‚˜ë¥¼ í™”ë©´ìƒì˜ ì¢Œí‘œë¡œ ë³€í™˜í•˜ëŠ” ì—­í• 
ê°€ìš´ë°ê°€ (0,0) ê¸°ì¤€ìœ¼ë¡œ ì ì„ ë³€í™˜í•´ì•¼í•¨
gl_Position - ë¯¸ë¦¬ ì •ì˜ëœ ë³€ìˆ˜ì— ê°’ì„ í•˜ë‚˜ì”© ê°€ì ¸ì™€ì„œ ì²˜ë¦¬
gl_Position = vec4(0,0,0,1);


fshader
í”½ì…€ í•˜ë‚˜ë‹¹ fshaderì˜ main ì‹¤í–‰ë¨
í•´ë‹¹ í”½ì…€ì— í•´ë‹¹í•˜ëŠ” fragmentì— ì˜í•œ ìƒ‰ìƒ ê°’ì„ out vec4 fColorë¡œ ë°˜í™˜

í•¨ìˆ˜ì˜ ì¸ìì™€ ë°˜í™˜ì„ in, out í‚¤ì›Œë“œë¡œ ë”°ë¡œ ì„¤ì •



vshader
```
#version 330

in vec4 vPosition;
in vec4 vColor;

out vec4 color;

void main()
{
	gl_Position = vPosition;
	color = vColor;
}
```


fshader
```
#version 330

in vec4 color;
out vec4 fColor;

void main()
{
	fColor = color;
}
```


main
```
#include <vgl.h>
#include <InitShader.h>
#include <vec.h>

vec4 vertex_pos[8] = {
	vec4(-0.5,-0.5, 0.5, 1),
	vec4(-0.5, 0.5, 0.5, 1),
	vec4(0.5, 0.5, 0.5, 1),
	vec4(0.5,-0.5, 0.5, 1),
	vec4(-0.5,-0.5,-0.5, 1),
	vec4(-0.5, 0.5,-0.5, 1),
	vec4(0.5, 0.5, -0.5, 1),
	vec4(0.5,-0.5, -0.5, 1)
};

vec4 vertex_color[8] = {
	vec4(1,0,0,1),
	vec4(0,1,0,1),
	vec4(0,0,1,1),
	vec4(1,1,0,1),
	vec4(0,1,1,1),
	vec4(1,0,1,1),
	vec4(1,1,1,1),
	vec4(0,0,0,1)
};

const int NumVertex = 6 * 2 * 3;
vec4 positions[NumVertex];
vec4 colors[NumVertex];


void makeRect(int a, int b, int c, int d)
{
	static int cur = 0;
	positions[cur] = vertex_pos[a];	colors[cur] = vertex_color[a]; cur++;
	positions[cur] = vertex_pos[b];	colors[cur] = vertex_color[b]; cur++;
	positions[cur] = vertex_pos[c];	colors[cur] = vertex_color[c]; cur++;

	positions[cur] = vertex_pos[c];	colors[cur] = vertex_color[c]; cur++;
	positions[cur] = vertex_pos[d];	colors[cur] = vertex_color[d]; cur++;
	positions[cur] = vertex_pos[a];	colors[cur] = vertex_color[a]; cur++;
}



void makeCube()
{
	// ì‹œê³„ ë°˜ëŒ€ë°©í–¥ìœ¼ë¡œ ê¼­ì§“ì  í•´ì„ (ì‚¼ê°í˜• ë§Œë“¤ ë•Œ)
	makeRect(0, 3, 2, 1);
	makeRect(4, 5, 6, 7);
	makeRect(0, 4, 7, 3);
	makeRect(3, 7, 6, 2);
	makeRect(2, 6, 5, 1);
	makeRect(1, 5, 4, 0);
	
}

void myInit()
{
	// Create data in CPU
	makeCube();

	// Send data to GPU
	//1. Setup VAO (gen and bind)
	GLuint vao;
	glGenVertexArrays(1, &vao);
	glBindVertexArray(vao);

	//2. Setup VBO (gen and bind)
	GLuint vbo;
	glGenBuffers(1, &vbo);
	glBindBuffer(GL_ARRAY_BUFFER, vbo);

	//3. Copy data to Buffer
	// ì„¸ë²ˆ ì§¸ ì¸ì NULLí•˜ë©´ ì•„ì§ ë°ì´í„°ëŠ” ì•ˆë³´ë‚´ê³  ë©”ëª¨ë¦¬ë§Œ ë™ì í• ë‹¹ ë¨
	glBufferData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(colors), NULL, GL_STATIC_DRAW);
	// ìœ„ì¹˜ ë°ì´í„°ë¥¼ ì¡íŒ ë©”ëª¨ë¦¬ì— ì²˜ìŒë¶€í„° ì§‘ì–´ë„£ìŒ
	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), positions);
	// ìƒ‰ìƒ ë°ì´í„°ë¥¼ ë©”ëª¨ë¦¬ì— 2ë²ˆì§¸ ì¸ì ìœ„ì¹˜ë¶€í„° ì§‘ì–´ë„£ìŒ
	glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(colors), colors);
	// ë”°ë¼ì„œ ì• ë¶€ë¶„ì€ ìœ„ì¹˜ ë°ì´í„°, ë’· ë¶€ë¶„ì€ ìƒ‰ìƒ ë°ì´í„°ë¥¼ ë°€ì–´ë„£ìŒ
	
	
	//4. Load Shaders
	// ì…°ì´ë”ê°€ ë¡œë“œ ë˜ê³  ë¡œë”©ëœ ì…°ì´ë”ì— ëŒ€í•œ í•¸ë“¤ì„ ë°›ì•„ì˜´
	GLuint prog = InitShader("vshader.glsl", "fshader.glsl");
	// ì…°ì´ë” ì‚¬ìš©
	glUseProgram(prog);
	

	//5. Connect shader to buffer
	// ì…°ì´ë”ì™€ ë°ì´í„°ë¥¼ ì—°ê²°í•˜ëŠ” ê³¼ì •
	// ë©”ëª¨ë¦¬ ì•ì˜ ìœ„ì¹˜í•œ ë°ì´í„°ì™€ ë©”ëª¨ë¦¬ ë’¤ì— ìœ„ì¹˜í•œ ìƒ‰ìƒ ë°ì´í„°ë¥¼ ì…°ì´ë”ê°€ ì–´ë–»ê²Œ í•´ì„í• ê±´ì§€ ì•Œë ¤ì¤˜ì•¼í•¨
	
	// vPosition
	// "ë‚´ê°€ ì•„ê¹Œ ë³´ë‚¸ vPosition ë³€ìˆ˜ê°€ ì…°ì´ë”ì— ìˆì„ê±°ì•¼" -> ë³€ìˆ˜ë¥¼ ì§€ì¹­í•˜ëŠ” í•¸ë“¤ ë°˜í™˜
	GLuint vPosition = glGetAttribLocation(prog, "vPosition");
	// "ê·¸ ë³€ìˆ˜ ë‚´ê°€ ì§€ê¸ˆ ë³´ë‚´ì¤„ê±°ì•¼" -> ì…°ì´ë”ì— in ìœ¼ë¡œ ë“¤ì–´ì˜´
	glEnableVertexAttribArray(vPosition);
	// "4ê°œì˜ float ë³€ìˆ˜ë¡œ ë˜ì–´ìˆì„ê±°ê³ , ì•„ê¹Œ ë³´ë‚¸ ë°ì´í„°ì˜ ì²˜ìŒë¶€í„°(BUFFER_OFFSET(0)) ì‹œì‘í•´ì„œ ì—°ì†í•´ì„œ ìˆì„ê±°ì•¼"
	glVertexAttribPointer(vPosition, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

	// vColor
	GLuint vColor = glGetAttribLocation(prog, "vColor");
	glEnableVertexAttribArray(vColor);
	// "4ê°œì˜ float ë³€ìˆ˜ë¡œ ë˜ì–´ìˆì„ê±°ê³ , ì•„ê¹Œ ë³´ë‚¸ ë°ì´í„°ì˜ sizeof(positions) ì´í›„ë¶€í„° ì‹œì‘í•´ì„œ ì—°ì†í•´ì„œ ìˆì„ê±°ì•¼"
	glVertexAttribPointer(vColor, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(sizeof(positions)));
	

	// 4ë²ˆì§¸ ì¸ì(GL_FALSE)ëŠ” ì˜ˆë¥¼ë“¤ì–´ vectorë¥¼ ë³´ë‚¼ ë•Œ í¬ê¸°ë¥¼ 1ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” nomarlizeë¥¼ ì“¸ì§€ ë§ì§€ ì •í•˜ëŠ” ê·¸ëŸ° ê¸°ëŠ¥
}

void myDisplay()
{
	glClear(GL_COLOR_BUFFER_BIT);
	//í˜„ì¬ ë°”ì¸ë”©ëœ Arrayë¥¼ í˜„ì¬ ë°”ì¸ë”©ëœ shader programìœ¼ë¡œ í™”ë©´ì— ê·¸ë¦¼
	glDrawArrays(GL_TRIANGLES, 0, NumVertex);
	glFlush();
}

int main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);
	glutInitWindowSize(512, 512);
	glutCreateWindow("Color Cube Example");

	glewExperimental = true;
	glewInit();

	myInit();

	glutDisplayFunc(myDisplay);
	glutMainLoop();

	return 0;
}

```


ìœ„ ê²°ê³¼ë¡œ zì¶•ìœ¼ë¡œ ë°”ë¼ë³¸ 2ì°¨ì› ì •ì‚¬ê°í˜•ìœ¼ë¡œ ë³´ì„

ì¹´ë©”ë¼ë¥¼ íšŒì „í•˜ì§€ ì•Šê³  vshaderì—ì„œ ë¬¼ì²´ë¥¼ í–‰ë ¬ì„ ê³±í•´ íšŒì „ì‹œí‚¬ ìˆ˜ ìˆìŒ
-> ì•ìœ¼ë¡œ ì´ëŸ° ê³¼ì •ì„ shaderë¥¼ ë°°ìš°ë©´ì„œ í•™ìŠµí•  ì˜ˆì •


glslì€ cì™€ ë¹„ìŠ·í•˜ì§€ë§Œ í¬ì¸í„°, ë™ì í• ë‹¹ ë“±ì˜ ë³µì¡í•œ ê¸°ëŠ¥ì´ ì—†ê³ ,
ìˆ˜í•™ ê´€ë ¨ëœ ê¸°ëŠ¥ì´ ë§ì´ ë“¤ì–´ìˆìŒ

