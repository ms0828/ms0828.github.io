---
title: "(OpenGL) Sphere ì‹¤ìŠµ - ë‹¤ê°í˜• ê·¼ì‚¬ ë°©ì‹"
excerpt: ""

categories:
  - Computer Graphics
tags:
  - [tag1, tag2]

permalink: /categories/computer_graphics/sphere/

toc: true
toc_sticky: true

date: 2024-10-09
last_modified_at: 2024-10-09
---

## ğŸ¦¥ Sphere
ì»´í“¨í„° ê·¸ë˜í”½ìŠ¤ì—ì„œ ì›ì„ ê·¸ë¦¬ëŠ” ë°©ë²•ì€ ì—¬ëŸ¬ê°€ì§€ê°€ ìˆë‹¤. ìˆ˜ì—… ì‹œê°„ì— ë‹¤ê°í˜• ê·¼ì‚¬ ë°©ì‹ì„ ì‚¬ìš©í•˜ì—¬ ì›ì„ ê·¸ë¦¬ëŠ” ì‹¤ìŠµì„ ë‹¤ìŒê³¼ ê°™ì´ ì •ë¦¬í•´ ë³´ì•˜ë‹¤. <br>

ì´ ë°©ë²•ì€ êµ¬ë¥¼ ì§êµ ì¢Œí‘œê³„ë¥¼ ë°”íƒ•ìœ¼ë¡œ íŠ¹ì • ê°„ê²©ì˜ ìœ„ë„ì™€ ê²½ë„ë¡œ ë‚˜ëˆˆ í›„, ê° ê²©ìë¥¼ ì‚¼ê°í˜•ì„ ì´ìš©í•´ í‘œí˜„í•œë‹¤.
<br>

### í•µì‹¬ ì•„ì´ë””ì–´
ë¨¼ì €, ê° ê²©ìì— í•´ë‹¹í•˜ëŠ” ì‚¼ê°í˜•ì˜ ì •ì  ì¢Œí‘œë¥¼ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í•œë‹¤. ì •ì ì€ x,y,zì˜ 3D ì¢Œí‘œê³„ë¡œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë¯€ë¡œ, ê° ë‹¨ë©´ì„ ì§œë¥¸ë‹¤ìŒ ì‚¼ê°í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ìˆœì°¨ì ìœ¼ë¡œ ì¢Œí‘œë¥¼ êµ¬í•´ë‚˜ê°„ë‹¤.<br>

<br>

![sphere1](/assets\images\posts_img\graphics\sphere1.png)
ì›ì„ XYì¶• ë‹¨ë©´ìœ¼ë¡œ ê°€ë¥´ë©´ ë‹¤ìŒê³¼ ê°™ì€ ëª¨ìŠµì´ ëœë‹¤. ì—¬ê¸°ì„œ ì›ì˜ ë§¨ ìœ„ ê¼­ì§“ì ìœ¼ë¡œë¶€í„° ì„¸ë¡œ ë°©í–¥ìœ¼ë¡œ ë²Œì–´ì§„ ê°ë„ë¥¼ dphië¡œ ê°€ì •í•œë‹¤.


<br>

![sphere2](/assets\images\posts_img\graphics\sphere2.png) 
ì´ ë•Œ, '? ì •ì 'ì˜ **y ì¢Œí‘œ**ì™€ ì›ì˜ ì„¸ë¡œ ì¶•ë¶€í„° '? ì •ì ' ê¹Œì§€ì˜ ê±°ë¦¬(ë‹¤ìŒ ê³¼ì •ì—ì„œ ì‚¬ìš©í•  ë°˜ì§€ë¦„ **r1**)ë¥¼ êµ¬í•˜ëŠ” ê²ƒì´ í•µì‹¬ì´ë‹¤.


<br> 

![sphere3](/assets\images\posts_img\graphics\sphere3.png) 
ë‹¤ìŒìœ¼ë¡œ í•´ë‹¹ ì •ì ì˜ **xì¶•**ê³¼ **zì¶•** ì¢Œí‘œë¥¼ êµ¬í•˜ê¸° ìœ„í•´, ì›ì„ XZì¶• ë‹¨ë©´ìœ¼ë¡œ ë°”ë¼ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. (ì›ì„ ìœ„ì—ì„œ ì•„ë˜ë¡œ ë°”ë¼ë³´ëŠ” ëª¨ìŠµ)<br>
(í•´ë‹¹ ì •ì ì´ xì¶•ìœ¼ë¡œ ë¶€í„° ë–¨ì–´ì§„ ê°„ê²©ì„ dthetaë¼ ê°€ì •í•œë‹¤.)<br>


<br>

![sphere4](/assets\images\posts_img\graphics\sphere4.png)
ê·¸ë¦¼ê³¼ ê°™ì´, r1ê³¼ ì‚¼ê°í•¨ìˆ˜ë¥¼ ì´ìš©í•´ xì™€ zì¶• ê°’ì„ ì‰½ê²Œ êµ¬í•  ìˆ˜ ìˆë‹¤. <br>
ìœ„ì—ì„œ r1 x sin(dtheta)ê°€ ì •ì ì˜ zì¶• ì¢Œí‘œì´ê³ , r1 x cos(dtheta)ê°€ ì •ì ì˜ xì¶• ì¢Œí‘œê°€ ëœë‹¤.
<br>

<br>
ë”°ë¼ì„œ ê²©ìë¥¼ êµ¬ì„±í•˜ëŠ” ì‚¼ê°í˜•ì˜ ëª¨ë“  ì •ì  ì¢Œí‘œë¥¼ êµ¬í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, GPUì—ê²Œ í•´ë‹¹ ì •ì  ì¢Œí‘œë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì „ì†¡í•˜ê³  ì‚¼ê°í˜•ì„ ì—°ì´ì–´ ê·¸ë¦°ë‹¤ë©´ ì›ì„ ê·¸ë¦´ ìˆ˜ ìˆê²Œ ëœë‹¤.

### ìµœì¢… ê²°ê³¼ë¬¼
![sphere5](/assets\images\posts_img\graphics\sphere5.png)

<br><br>


### ì½”ë“œ

```
class MySphere {
public:
	int m_numLaSlice, m_numLoSlice;		// latitude(ìœ„ë„=ê°€ë¡œë‹¨ë©´ì˜ ê°¯ìˆ˜), longitude(ê²½ë„=ì„¸ë¡œë‹¨ë©´)
	int m_numVertices;
	GLuint m_vao;
	GLuint m_vbo;
	bool m_bInit;

	MySphere() {
		m_numLaSlice = 0;
		m_numLoSlice = 0;
		m_numVertices = 0;
		m_bInit = false;
	}
	void init(int laSlice, int loSlice, float radius = 1.0f) {

		m_numLaSlice = laSlice;
		m_numLoSlice = loSlice;
		m_numVertices = loSlice * 2 * 3				// ìœ„ì•„ë˜ ëšœê»‘ì˜ ì‚¼ê°í˜•ê°¯ìˆ˜
			+ (laSlice - 2) * loSlice * 2 * 3;	// ëšœê»‘ì„ ì œì™¸í•œ ë‹¨ë©´ì˜ ê°¯ìˆ˜(laSlice-2)

		MySphereVertex* vertices = new MySphereVertex[m_numVertices];
		float r = radius;
		float dphi = 3.141592 / laSlice;
		float dtheta = 2 * 3.141592 / loSlice;

		int cur = 0;
		for (int j = 0; j < laSlice; j++)
		{
			float y1 = r * cos(dphi * j);
			float r1 = r * sin(dphi * j);

			float y2 = r * cos(dphi * (j + 1));
			float r2 = r * sin(dphi * (j + 1));

			for (int i = 0; i < loSlice; i++)
			{
				float x1 = cos(dtheta * i);
				float z1 = sin(dtheta * i);

				float x2 = cos(dtheta * (i + 1));
				float z2 = sin(dtheta * (i + 1));

				vec4 a = vec4(r1 * x1, y1, r1 * z1, 1);
				vec4 b = vec4(r1 * x2, y1, r1 * z2, 1);
				vec4 c = vec4(r2 * x1, y2, r2 * z1, 1);
				vec4 d = vec4(r2 * x2, y2, r2 * z2, 1);
				
				vec4 color = vec4(0.5, 0.5, 0.5, 1);
				if ((i + j) % 2 == 1) color = vec4(0.8, 0.8, 0.8, 1);

				if (j != 0)
				{
					vertices[cur].position = a;	vertices[cur].color = color; cur++;
					vertices[cur].position = b;	vertices[cur].color = color; cur++;
					vertices[cur].position = c;	vertices[cur].color = color; cur++;
				}
				if (j != laSlice - 1)
				{
					vertices[cur].position = c;	vertices[cur].color = color; cur++;
					vertices[cur].position = b;	vertices[cur].color = color; cur++;
					vertices[cur].position = d;	vertices[cur].color = color; cur++;
				}
			}
		}

		if (m_bInit == false)
		{
			glGenVertexArrays(1, &m_vao);
			glBindVertexArray(m_vao);

			glGenBuffers(1, &m_vbo);
			glBindBuffer(GL_ARRAY_BUFFER, m_vbo);
		}
		else
		{
			glBindVertexArray(m_vao);
			glBindBuffer(GL_ARRAY_BUFFER, m_vbo);
		}

		glBufferData(GL_ARRAY_BUFFER, sizeof(MySphereVertex) * m_numVertices, vertices,
			GL_STATIC_DRAW);

		delete[] vertices;
		m_bInit = true;
	}
	void connectShaderWithProgram(GLuint prog) {
		GLuint vPosition = glGetAttribLocation(prog, "vPosition");
		glEnableVertexAttribArray(vPosition);
		glVertexAttribPointer(vPosition, 4, GL_FLOAT, GL_FALSE,
			sizeof(MySphereVertex), BUFFER_OFFSET(0));

		GLuint vColor = glGetAttribLocation(prog, "vColor");
		glEnableVertexAttribArray(vColor);
		glVertexAttribPointer(vColor, 4, GL_FLOAT, GL_FALSE,
			sizeof(MySphereVertex), BUFFER_OFFSET(sizeof(vec4)));
	}
	void draw(GLuint prog) {
		glBindVertexArray(m_vao);
		glUseProgram(prog);
		connectShaderWithProgram(prog);
		glDrawArrays(GL_TRIANGLES, 0, m_numVertices);

	}
};
```
