---
title: "(OpenGL) Shader 생성과 로딩"
excerpt: ""

categories:
  - Computer Graphics
tags:
  - [tag1, tag2]

permalink: /categories/computer_graphics/generate_shader/

toc: true
toc_sticky: true

date: 2024-09-23
last_modified_at: 2024-09-23
---

## 🦥 Shader
과거 그래픽스 파이프라인은 GPU가 고정된 방식으로 데이터를 처리하였다면, 현재는 사용자가 그래픽스 파이프라인의 동작 방식을 컨트롤 할 수 있게 되었다. 
> 사용자가 Vertex Processor, Fragment Processor 등 GPU 동작 방식을 프로그램으로 정의한 것을 Shader라고 부른다.

<br>
최신 OpenGL에서 사용하고 있는 그래픽스 파이프라인은 다음과 같다.

![OpenGL 4.5 Pipelines](/assets\images\posts_img\graphics\opengl4.5pipeline.png)

위와 같은 프로그래머블 파이프라인은 OpenGL 2.0부터 도입되기 시작하여 OpenGL 4.5와 같은 최신 버전에서는 표준이 되었다. 사용자는 그래픽 처리의 중요한 단계를 직접 제어할 수 있게 되었다. => Shader Programming 도입


> 따라서 최신 OpenGL을 사용하려면 정점이 화면 상에 어디에 위치할지를 정의하는 Vertex Shader와 어떤 색상을 가질지를 정의하는 Fragment Shader를 사용자가 직접 만들어서 연결해줘야 한다. (옛날 고정된 파이프라인에서는 작성할 필요가 없었음)

<br><br>

이전 글에서 GPU 메모리에 데이터를 전송하는 방법을 소개하였다. 이어서 Vertex Shader와 Fragment Shader를 만들고 데이터와 연결해주는 작업이 필요한데, 과정은 다음과 같다.

1. Create Shader Program
2. Load Shader Programs
3. Connect Data With Shader

<br><br>


### Create Shader Program
OpenGL에서 셰이더를 만들려면 .glsl 확장 프로그램으로 코드를 작성해야한다.

아래는 가장 간단한 Vertex Shader와 Fragment Shader를 작성한 것이다.

<br>


vertexShader.glsl
```
#version 330
in vec4 vPosition;
void main()
{
	gl_Position = vPosition;
}
```
<br>

fragmentShader.glsl
```
#version 330
out vec4 fColor;
void main()
{
	fColor = vec4(1.0, 1.0, 1.0, 1.0);		// r, g, b, alpha
}
```

<br><br>

### Load Shader Programs And Connect Data With Shader
다음은 GPU 메모리에 데이터를 전송한 후, 작성한 셰이더를 로딩하여 각 데이터와 연결하는 코드이다.

```
#include <vgl.h>
#include <math.h>
#include <InitShader.h>

struct vec2 
{
	float x, y;
};

void init()
{
	const int NUM_POINTS = 500;

	// Generate Data in CPU
	vec2 points[NUM_POINTS];
	for (int i = 0; i < NUM_POINTS; i++)
	{
		points[i].x = (rand() % 1000) / 500.0f - 1;
		points[i].y = (rand() % 1000) / 500.0f - 1;
	}
	

	// 1. Generate Vertex Array
	GLuint vao;
	glGenVertexArrays(1, &vao);

	// 2. Bind the Vertex Array
	glBindVertexArray(vao);
	
	// 3. Generate a Vertex Buffer Object
	GLuint vbo;
	glGenBuffers(1, &vbo);
	
	// 4. Bind the Buffer Object
	glBindBuffer(GL_ARRAY_BUFFER, vbo);
	

	// 5. Copy data to the buffer
	glBufferData(GL_ARRAY_BUFFER, sizeof(points), points, GL_STATIC_DRAW);



	// Load Shaders
	GLuint program;
	program = InitShader("vshader.glsl", "fshader.glsl");	// 셰이더를 gpu에 보내서 gpu가 컴파일 후 로드 -> 핸들 반환
	glUseProgram(program);
	
	
	// Connect data with shader
	// 데이터와 셰이더의 매핑 방법을 기술 
	// "셰이더가 데이터를 어떻게 읽을껀데?"
	// ex "앞 에 데이터를 두개씩 끊어서 하나의 점으로 해석해줘"
	int vPosition = 0;
	glEnableVertexAttribArray(vPosition);
	glVertexAttribPointer(vPosition, 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));
	// "vPosition 라는 변수는 float에 해당하는 변수는 2개씩 연속해서 읽으면 돼!"
}

void display()
{
	glClear(GL_COLOR_BUFFER_BIT);
	
	glDrawArrays(GL_POINTS, 0, NUM_POINTS);		// "아까 전송한 데이터를 점으로 그려줘!" (마지막 바인딩된 Array를 대상으로) 
	
	glFlush();
}

int main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);
	glutInitWindowSize(800, 800);
	glutCreateWindow("Hello GL");

	glewExperimental = true;
	glewInit();

	init();	// 데이터를 만들고 전송하는 Init은 glewInit() 이 후에 사용해야함
	glutDisplayFunc(display);
	glutMainLoop();

	return 0;
}

```

