---
title: "(OpenGL) Shader"
excerpt: ""

categories:
  - Computer Graphics
tags:
  - [tag1, tag2]

permalink: /categories/computer_graphics/generate_shader/

toc: true
toc_sticky: true

date: 2024-09-23
last_modified_at: 2024-09-23
---

## ğŸ¦¥ Shader
ê³¼ê±° ê·¸ë˜í”½ìŠ¤ íŒŒì´í”„ë¼ì¸ì€ GPUê°€ ê³ ì •ëœ ë°©ì‹ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ì˜€ë‹¤ë©´, í˜„ì¬ëŠ” ì‚¬ìš©ìê°€ ê·¸ë˜í”½ìŠ¤ íŒŒì´í”„ë¼ì¸ì˜ ë™ì‘ ë°©ì‹ì„ ì»¨íŠ¸ë¡¤ í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤. 
> ì‚¬ìš©ìê°€ Vertex Processor, Fragment Processor ë“± GPU ë™ì‘ ë°©ì‹ì„ ì •ì˜í•œ í”„ë¡œê·¸ë¨ì„ Shader Programì´ë¼ê³  ë¶€ë¥¸ë‹¤.

<br>
ìµœì‹  OpenGLì—ì„œ ì‚¬ìš©í•˜ê³  ìˆëŠ” ê·¸ë˜í”½ìŠ¤ íŒŒì´í”„ë¼ì¸ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

![OpenGL 4.5 Pipelines](/assets\images\posts_img\graphics\opengl4.5pipeline.png)

ìœ„ì™€ ê°™ì€ í”„ë¡œê·¸ë˜ë¨¸ë¸” íŒŒì´í”„ë¼ì¸ì€ OpenGL 2.0ë¶€í„° ë„ì…ë˜ê¸° ì‹œì‘í•˜ì—¬ OpenGL 4.5ì™€ ê°™ì€ ìµœì‹  ë²„ì „ì—ì„œëŠ” í‘œì¤€ì´ ë˜ì—ˆë‹¤. ì‚¬ìš©ìëŠ” ê·¸ë˜í”½ ì²˜ë¦¬ì˜ ì¤‘ìš”í•œ ë‹¨ê³„ë¥¼ ì§ì ‘ ì œì–´í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤. => Shader Programming ë„ì…


> ë”°ë¼ì„œ ìµœì‹  OpenGLì„ ì‚¬ìš©í•˜ë ¤ë©´ ì •ì ì´ í™”ë©´ ìƒì— ì–´ë””ì— ìœ„ì¹˜í• ì§€ë¥¼ ì •ì˜í•˜ëŠ” Vertex Shaderì™€ ì–´ë–¤ ìƒ‰ìƒì„ ê°€ì§ˆì§€ë¥¼ ì •ì˜í•˜ëŠ” Fragment Shaderë¥¼ ì‚¬ìš©ìê°€ ì§ì ‘ ë§Œë“¤ì–´ì„œ ì—°ê²°í•´ì¤˜ì•¼ í•œë‹¤. (ì˜›ë‚  ê³ ì •ëœ íŒŒì´í”„ë¼ì¸ì—ì„œëŠ” ì‘ì„±í•  í•„ìš”ê°€ ì—†ì—ˆìŒ)

<br><br>

ì´ì „ ê¸€ì—ì„œ GPU ë©”ëª¨ë¦¬ì— ë°ì´í„°ë¥¼ ì „ì†¡í•˜ëŠ” ë°©ë²•ì„ ì†Œê°œí•˜ì˜€ë‹¤. ì´ì–´ì„œ Vertex Shaderì™€ Fragment Shaderë¥¼ ë§Œë“¤ê³  ë°ì´í„°ì™€ ì—°ê²°í•´ì£¼ëŠ” ì‘ì—…ì´ í•„ìš”í•œë°, ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

1. Create Shader Program
2. Load Shader Programs
3. Connect Data With Shader

<br><br>


### Create Shader Program
OpenGLì—ì„œ ì…°ì´ë”ë¥¼ ë§Œë“¤ë ¤ë©´ .glsl í™•ì¥ í”„ë¡œê·¸ë¨ìœ¼ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼í•œë‹¤. <br>

ì•„ë˜ëŠ” ê°€ì¥ ê°„ë‹¨í•œ Vertex Shaderì™€ Fragment Shaderë¥¼ ì‘ì„±í•œ ê²ƒì´ë‹¤.<br>
ì´ë ‡ê²Œ ë§Œë“¤ì–´ì§„ ì‰ì´ë” í”„ë¡œê·¸ë¨ì€ GPUì—ì„œ ì»´íŒŒì¼ë˜ê³  íŒŒì´í”„ë¼ì¸ ë‹¨ê³„ì—ì„œ ì²˜ë¦¬ëœë‹¤. <br>

> Shading LanguageëŠ” ì¶”í›„ ìˆ˜ì—…ì„ ë“£ê³  ì •ë¦¬í•  ì˜ˆì •

<br>


vertexShader.glsl
```
#version 330
in vec4 vPosition;
void main()
{
	gl_Position = vPosition;
}
```
<br>

fragmentShader.glsl
```
#version 330
out vec4 fColor;
void main()
{
	fColor = vec4(1.0, 1.0, 1.0, 1.0);		// r, g, b, alpha
}
```

<br><br>

### Load Shader Programs
ë‹¤ìŒì€ GPU ë©”ëª¨ë¦¬ì— ë°ì´í„°ë¥¼ ì „ì†¡í•œ ì´í›„, ì‘ì„±í•œ ì…°ì´ë”ë¥¼ ë¡œë”©í•˜ëŠ” ê³¼ì •ì´ë‹¤.

> í•„ìš” í—¤ë” íŒŒì¼ <br>
	#include <InitShader.h>

InitShader í•¨ìˆ˜ë¥¼ í†µí•´ Vertex Shaderì™€ Fragment Shaderë¥¼ ë¡œë“œí•˜ë©´ GPUëŠ” ì…°ì´ë” íŒŒì¼ì„ ì»´íŒŒì¼í•˜ê³  ë¡œë”©ëœ ì…°ì´ë”ì— ëŒ€í•œ í•¸ë“¤ì„ ë°˜í™˜í•œë‹¤.<br>
í•¸ë“¤ì€ ì–‘ìˆ˜ ê°’ìœ¼ë¡œ GLuint íƒ€ì…ìœ¼ë¡œ ë°›ì„ ìˆ˜ ìˆë‹¤. <br>

<br>

ì´í›„ glUseProgram í•¨ìˆ˜ë¥¼ í†µí•´ ì¸ìë¡œ ë“¤ì–´ì˜¬ ì…°ì´ë” í•¸ë“¤ì„ ê°€ë™ì‹œí‚¨ë‹¤. 

```
// Load Shaders
	GLuint program;
	program = InitShader("vshader.glsl", "fshader.glsl");	// ì…°ì´ë”ë¥¼ gpuì— ë³´ë‚´ì„œ gpuê°€ ì»´íŒŒì¼ í›„ ë¡œë“œ -> í•¸ë“¤ ë°˜í™˜
	glUseProgram(program);
```


### Connect Data With Shader
ë‹¤ìŒì€ ì…°ì´ë”ì™€ GPUì— ë¡œë“œëœ ë°ì´í„°ë¥¼ ë§¤í•‘í•˜ëŠ” ê³¼ì •ìœ¼ë¡œ, ë²„í¼ë¡œ ì „ë‹¬í•œ ë©”ëª¨ë¦¬ë¥¼ ì…°ì´ë”ê°€ ì–´ë–»ê²Œ í•´ì„í• ê±´ì§€ ì•Œë ¤ì£¼ëŠ” ê³¼ì •ì´ë‹¤.

- ex "ì•ì— ì •ì  ë°ì´í„°ë¥¼ ë‘ê°œì”© ëŠì–´ì„œ í•˜ë‚˜ì˜ ì ìœ¼ë¡œ í•´ì„í•´ì¤˜!"
- ex "ë©”ëª¨ë¦¬ ì• ë¶€ë¶„ì€ ì •ì  ìœ„ì¹˜ ë°ì´í„°ê³  ë©”ëª¨ë¦¬ ë’· ë¶€ë¶„ì€ ìƒ‰ìƒ ë°ì´í„°ë¡œ ì½ì–´ì¤˜!"

```
// Connect data with shader
	// ë°ì´í„°ì™€ ì…°ì´ë”ì˜ ë§¤í•‘ ë°©ë²•ì„ ê¸°ìˆ  
	// "ì…°ì´ë”ê°€ ë²„í¼ë¡œ ë¶€í„° ë°ì´í„°ë¥¼ ì–´ë–»ê²Œ ì½ì„ê»€ë°?"
	
	GLuint vPosition = glGetAttribLocation(program, "vPosition");
	glEnableVertexAttribArray(vPosition);
	glVertexAttribPointer(vPosition, 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));
	// "vPosition ë¼ëŠ” ë³€ìˆ˜ëŠ” floatìœ¼ë¡œ 2ê°œì”© ë¬¶ì–´ ì—°ì†í•´ì„œ í•´ì„í•˜ë©´ ë¼!"
```

ìœ„ ì½”ë“œë¥¼ í•´ì„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
- glGetAttribLocation(program, "vPosition")ë¡œ ì…°ì´ë” í”„ë¡œê·¸ë¨ ì•ˆì— ìˆëŠ” vPosition ë³€ìˆ˜ë¥¼ ì°¾ì•„ í•´ë‹¹ ë³€ìˆ˜ì— ëŒ€í•œ í•¸ë“¤(ì¸ë±ìŠ¤)ì„ ë°˜í™˜í•œë‹¤.
- glEnableVertexAttribArray(vPosition)ë¡œ vPosition(attribute index)ì— í•´ë‹¹í•˜ëŠ” ì†ì„±ì„ í™œì„±í™” ì‹œí‚¤ê³ , OpenGLì´ í™œì„±í™”í•œ ì†ì„±ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì½ì–´ ë“¤ì¼ ìˆ˜ ìˆë„ë¡ í•œë‹¤.
- glVertexAttribPointer(handle, ...) í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ í˜„ì¬ í™œì„±í™”ëœ ë²„í¼ ë©”ëª¨ë¦¬ë¥¼ ì–´ë–»ê²Œ í•´ì„í•˜ì—¬ í•¸ë“¤ì— ëŒ€í•œ ë³€ìˆ˜ì— ì €ì¥í• ì§€ ì •ì˜í•œë‹¤.
- ì´í›„ ì…°ì´ë”ëŠ” í™œì„±í™”ëœ ë²„í¼ ë©”ëª¨ë¦¬ë¡œë¶€í„° ì‚¬ìš©ìê°€ ì •ì˜í•œ ë°©ë²•ìœ¼ë¡œ vPositionì— ë°ì´í„°ë¥¼ ì½ì–´ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ëœë‹¤.

<br><br><br>



### ì§€ê¸ˆê¹Œì§€ ë°°ìš´ ë‚´ìš© ì „ì²´ ì½”ë“œ ì˜ˆì œ

Vertex Shader
```
#version 330

in vec4 vPosition;
in vec4 vColor;

out vec4 color;

void main()
{
	gl_Position = vPosition;
	color = vColor;
}
```

<br>

Fragment Shader
```
#version 330

in vec4 color;
out vec4 fColor;

void main()
{
	fColor = vec4(1.0, 1.0, 1.0, 1.0);
}
```

<br>

```
#include <vgl.h>
#include <math.h>
#include <InitShader.h>

struct vec2 
{
	float x, y;
};
const int NumPOINTS = 5000;

void init()
{
	// Generate Data in CPU
	vec2 points[NUM_POINTS];
	for (int i = 0; i < NUM_POINTS; i++)
	{
		points[i].x = (rand() % 1000) / 500.0f - 1;
		points[i].y = (rand() % 1000) / 500.0f - 1;
	}
	

	// 1. Generate Vertex Array
	GLuint vao;
	glGenVertexArrays(1, &vao);

	// 2. Bind the Vertex Array
	glBindVertexArray(vao);
	
	// 3. Generate a Vertex Buffer Object
	GLuint vbo;
	glGenBuffers(1, &vbo);
	
	// 4. Bind the Buffer Object
	glBindBuffer(GL_ARRAY_BUFFER, vbo);
	

	// 5. Copy data to the buffer
	glBufferData(GL_ARRAY_BUFFER, sizeof(points), points, GL_STATIC_DRAW);



	// Load Shaders
	GLuint program;
	program = InitShader("vshader.glsl", "fshader.glsl");	// ì…°ì´ë”ë¥¼ gpuì— ë³´ë‚´ì„œ gpuê°€ ì»´íŒŒì¼ í›„ ë¡œë“œ -> í•¸ë“¤ ë°˜í™˜
	glUseProgram(program);
	
	
	// Connect data with shader
	// ë°ì´í„°ì™€ ì…°ì´ë”ì˜ ë§¤í•‘ ë°©ë²•ì„ ê¸°ìˆ  
	GLuint vPosition = glGetAttribLocation(program, "vPosition");
	glEnableVertexAttribArray(vPosition);
	glVertexAttribPointer(vPosition, 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

}

void display()
{
	glClear(GL_COLOR_BUFFER_BIT);
	
	glDrawArrays(GL_POINTS, 0, NUM_POINTS);		// "ì•„ê¹Œ ì „ì†¡í•œ ë°ì´í„°ë¥¼ ì ìœ¼ë¡œ ê·¸ë ¤ì¤˜!" (ë§ˆì§€ë§‰ ë°”ì¸ë”©ëœ Arrayë¥¼ ëŒ€ìƒìœ¼ë¡œ) 
	
	glFlush();
}

int main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);
	glutInitWindowSize(800, 800);
	glutCreateWindow("Hello GL");

	glewExperimental = true;
	glewInit();

	init();	// ë°ì´í„°ë¥¼ ë§Œë“¤ê³  ì „ì†¡í•˜ëŠ” Initì€ glewInit() ì´ í›„ì— ì‚¬ìš©í•´ì•¼í•¨
	glutDisplayFunc(display);
	glutMainLoop();

	return 0;
}

```

