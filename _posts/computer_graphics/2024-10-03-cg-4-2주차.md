---
title: "(OpenGL) Z-Buffer"
excerpt: ""

categories:
  - Computer Graphics
tags:
  - [tag1, tag2]

permalink: /categories/computer_graphics/z_buffer/

toc: true
toc_sticky: true

date: 2024-10-03
last_modified_at: 2024-10-03
---

ì •ìœ¡ë©´ì²´ë¥¼ matrixë¥¼ ì´ìš©í•´ íšŒì „ì‹œí‚¤ë‹¤ ë³´ë©´, ë‹¤ìŒê³¼ ê°™ì´ ë¶€ìì—°ìŠ¤ëŸ¬ìš´ ëª¨ìŠµì´ ë‚˜íƒ€ë‚œë‹¤. 

![cube](/assets\images\posts_img\graphics\rotatecube.png)

ì´ëŠ” ë¬¼ì²´ì˜ ê¹Šì´ë¥¼ ì²˜ë¦¬í•˜ì§€ ëª»í•˜ì˜€ê¸° ë•Œë¬¸ì´ë‹¤.<br>
> raytracingì´ ì•„ë‹Œ graphcis pipelineì—ì„œ ì •ìœ¡ë©´ì²´ë¥¼ ë Œë”ë§í•˜ê²Œ ë˜ë©´, Rasterizerê³¼ì •ì—ì„œ ì •ì ìœ¼ë¡œ êµ¬ì„±ëœ ì‚¼ê°í˜•ì— ëŒ€í•œ í”½ì…€ì„ ì²˜ë¦¬í•˜ê²Œ ëœë‹¤. <br> ë¬¼ì²´ì˜ ê¹Šì´ë¥¼ ì²˜ë¦¬í•˜ì§€ ì•Šìœ¼ë©´ íšŒì „í•˜ê±°ë‚˜ ê²¹ì¹˜ëŠ” ë¬¼ì²´ì˜ ê¹Šì´ì— ëŒ€í•œ ì •ë³´ê°€ ì—†ê¸° ë•Œë¬¸ì—, ìœ„ì™€ ê°™ì´ ê·¸ë¦¬ê¸° ìˆœì„œì— ë”°ë¼ ê°€ê¹Œìš´ ë©´ê³¼ ë¨¼ ë©´ì´ ë’¤ì„ì—¬ ë³´ì´ê²Œ ëœë‹¤.

<br><br>

## ğŸ¦¥ Z-Buffer
Z-bufferëŠ” ë¬¼ì²´ë¥¼ ê·¸ë¦´ ë•Œ, ê° í”½ì…€ì— ë³´ì—¬ì§€ëŠ” ë¬¼ì²´ì— ëŒ€í•œ ê¹Šì´ ê°’ì„ ë”°ë¡œ ì €ì¥í•´ ë§¤ë²ˆ ë¬¼ì²´ì˜ ê¹Šì´ë¥¼ ë¹„êµí•˜ëŠ” ë°©ì‹ì´ë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ Color bufferê°€ í”½ì…€ì˜ ìƒ‰ìƒì„ ì €ì¥í•˜ëŠ” ê²ƒì²˜ëŸ¼, Z-bufferëŠ” ê° í”½ì…€ì˜ ê¹Šì´ ê°’ì„ ì €ì¥í•˜ì—¬, ë” ê°€ê¹Œìš´ ë¬¼ì²´ë§Œ í™”ë©´ì— ê·¸ë¦¬ë„ë¡ í•œë‹¤.

Z-bufferë¥¼ ì‚¬ìš©í•˜ë©´, ë§¤ë²ˆ ëª¨ë“  ì‚¼ê°í˜•ì„ z-sorting(zê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬) í•˜ì§€ ì•Šê³ ë„ ì ì€ ë©”ëª¨ë¦¬ì™€ ì—°ì‚°ìœ¼ë¡œë„ ë¬¼ì²´ì˜ ê¹Šì´ ìš°ì„ ìˆœìœ„ë¥¼ íŒë‹¨í•  ìˆ˜ ìˆê²Œ ëœë‹¤.<br> ë˜í•œ ì‚¼ê°í˜•ì„ ê·¸ë¦´ ë•Œ, Z-bufferì— ì €ì¥ëœ ê¹Šì´ ê°’ê³¼ í˜„ì¬ ê·¸ë¦¬ë ¤ëŠ” ì‚¼ê°í˜•ì˜ ê¹Šì´ ê°’ì„ ë¹„êµí•˜ì—¬, ê°€ê¹Œìš´ ì‚¼ê°í˜•ë§Œ ê·¸ë¦¬ë©´ ë˜ê¸° ë•Œë¬¸ì— íš¨ìœ¨ì ì´ë‹¤.

<br><br>


### OpenGLì—ì„œ Z-buffer ì‚¬ìš©í•˜ê¸°
OpenGLì—ì„œ Z-bufferë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ glutInitDisplayModeì—ì„œ GLUT_DEPTHë¥¼ ì„¤ì •í•´ì¤˜ì•¼ í•œë‹¤.

```
glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);
```
<br>

ë˜í•œ ë²„í¼ë¥¼ ì´ˆê¸°í™”í•  ë•Œ DEPTH_BUFFER ë˜í•œ ì´ˆê¸°í™”í•˜ëŠ” ê³¼ì •ì´ í•„ìš”í•˜ë‹¤.

```
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glEnable(GL_DPETH_TEST);
```

<br><br>

ìœ„ ê³¼ì •ì„ ê±°ì¹œ í›„, ë‹¤ì‹œ ì •ìœ¡ë©´ì²´ë¥¼ íšŒì „ì‹œì¼œë³´ë©´ ë‹¤ìŒê³¼ ê°™ì´ ì •ìƒì ìœ¼ë¡œ ë¬¼ì²´ì˜ ê¹Šì´ ì²˜ë¦¬ê°€ ëœ ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.

![cube2](/assets\images\posts_img\graphics\rotatecube2.png)

<br><br>

### ì „ì²´ ì½”ë“œ

vshader
```
#version 330

uniform float uTime;

in vec4 vPosition;			// x,y,z,1		-> vec3 ->vec4
in vec4 vColor;

out vec4 color;

void main()
{
	float ang = uTime*90/180.0f*3.141592f;

	mat4 m = mat4(1.0f);			//[1 0 0 0]
	// z-rotation					//[0 1 0 0]
									//[0 0 1 0]
									//[0 0 0 1]
	m[0][0] = cos(ang);
	m[2][0] = sin(ang);
	m[0][2] = -sin(ang);
	m[2][2] = cos(ang);


	gl_Position = m*vPosition;

	gl_Position.w = 1.0f;
	color = vColor;
}
```

fshader
```
#version 330

in vec4 color;
out vec4 fColor;

void main()
{
	fColor = color;
}
```

main
```
#include <vgl.h>
#include <InitShader.h>
#include <vec.h>

// (x,y,z) --> (x,y,z,w=1) 
// (r,g,b) --> (r,g,b,a=1)

const int NUM_VERTEX = 6 * 2 * 3;
vec4 points[NUM_VERTEX];
vec4 colors[NUM_VERTEX];

GLuint program;

vec4 vertex_pos[] = {
	vec4(-0.5,-0.5, 0.5,1),
	vec4(0.5,-0.5, 0.5,1),
	vec4(0.5, 0.5, 0.5,1),
	vec4(-0.5, 0.5, 0.5,1),
	vec4(-0.5,-0.5,-0.5,1),
	vec4(0.5,-0.5,-0.5,1),
	vec4(0.5, 0.5,-0.5,1),
	vec4(-0.5, 0.5,-0.5,1)
};
vec4 vertex_color[] = {
	vec4(1, 0, 0, 1),
	vec4(0, 1, 0, 1),
	vec4(0, 0, 1, 1),
	vec4(1, 1, 0, 1),
	vec4(0, 1, 1, 1),
	vec4(1, 0, 1, 1),
	vec4(1, 1, 1, 1),
	vec4(0, 0, 0, 1)
};

void setRectangle(int a, int b, int c, int d)
{
	static int vindex = 0;
	points[vindex] = vertex_pos[a];		colors[vindex] = vertex_color[a];  vindex++;
	points[vindex] = vertex_pos[b];		colors[vindex] = vertex_color[b];  vindex++;
	points[vindex] = vertex_pos[c];		colors[vindex] = vertex_color[c];  vindex++;

	points[vindex] = vertex_pos[c];		colors[vindex] = vertex_color[c];  vindex++;
	points[vindex] = vertex_pos[d];		colors[vindex] = vertex_color[d];  vindex++;
	points[vindex] = vertex_pos[a];		colors[vindex] = vertex_color[a];  vindex++;

}

void generateCube() {
	setRectangle(0, 3, 2, 1);
	setRectangle(0, 4, 7, 3);
	setRectangle(3, 7, 6, 2);
	setRectangle(2, 6, 5, 1);
	setRectangle(1, 5, 4, 0);
	setRectangle(4, 5, 6, 7);
}

void myInit()
{
	// 1. create data in CPU
	generateCube();

	// 2. send the data to GPU
	GLuint vao;
	glGenVertexArrays(1, &vao);
	glBindVertexArray(vao);

	GLuint vbo;
	glGenBuffers(1, &vbo);
	glBindBuffer(GL_ARRAY_BUFFER, vbo);

	glBufferData(GL_ARRAY_BUFFER, sizeof(points) + sizeof(colors), NULL, GL_STATIC_DRAW);
	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(points), points);
	glBufferSubData(GL_ARRAY_BUFFER, sizeof(points), sizeof(colors), colors);

	// 3. load shaders

	program = InitShader("vshader.glsl", "fshader.glsl");
	glUseProgram(program);

	// 4. Connect my data with the shaders
	GLuint vPosition = glGetAttribLocation(program, "vPosition");
	glEnableVertexAttribArray(vPosition);
	glVertexAttribPointer(vPosition, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

	GLuint vColor = glGetAttribLocation(program, "vColor");
	glEnableVertexAttribArray(vColor);
	glVertexAttribPointer(vColor, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(sizeof(points)));
}

float myTime = 0;

void display()
{
	GLuint uTime = glGetUniformLocation(program, "uTime");
	glUniform1f(uTime, myTime);

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glDrawArrays(GL_TRIANGLES, 0, NUM_VERTEX);
	glEnable(GL_DEPTH_TEST);
	glFlush();
}

void idle()
{
	myTime += 0.0333f;
	Sleep(33);				// 33 milisecond
	glutPostRedisplay();
}

int main(int argc, char** argv)
{
	glutInit(&argc, argv);

	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA | GLUT_DEPTH);
	glutInitWindowSize(800, 800);
	glutCreateWindow("A Color Cube");

	glewExperimental = true;
	glewInit();

	myInit();

	glutDisplayFunc(display);
	glutIdleFunc(idle);

	glutMainLoop();

	return 0;
}
```




