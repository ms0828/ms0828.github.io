---
title: "C++ 비트 연산과 활용"
excerpt: "비트 연산은 어떻게 활용될까"

categories:
  - C/C++
tags:
  - [c,cpp]

permalink: /categories/c/bit

toc: true
toc_sticky: true

date: 2024-01-19
last_modified_at: 2024-01-19
---
## 비트 연산과 활용

비트 연산은 말 그대로 데이터 처리 단위인 비트를 사용해서 연산을 수행하는 것을 말한다. 그럼 왜 편한 자료형을 놔두고 비트를 사용할까? <br>
* 다른 연산보다 속도가 빠르다.
* 메모리를 효율적으로 사용할 수 있다.
* 비트 마스크를 사용하면 여러 상태를 직관적이고 가독성있게 표현할 수 있다. (게임 캐릭터의 상태이상을 나타낸다거나)

따라서 속도와 효율적인 메모리 사용이 중요한 게임 프로그래밍에서 많이 사용된다고 한다.

> bit연산은 부호가 없는 unsigned를 사용한다. (부호 비트가 딸려오지 않도록 하기 위해)

<br>

<실습을 위해 'bitset' 라이브러리를 사용>
```
#include<bitset>    // 10진수를 2진수 비트로 표현하게 해주는 라이브러리
using namespace std;
int main()
{
    int a = 5;
    cout << bitset<4>(a) << endl;     // a(5)를 4자리 비트로 출력하는 코드
    // 출력 결과 : 0101
}
```
<br><br>

## Shift
비트를 특정 수 만큼 좌,우로 옮기는 연산이다.
> 남는 자리는 0으로 채워지고, 자리를 넘어가는 비트는 소실된다.

비트를 옮기는건 무엇을 의미할까? <br> 각 비트의 자리 수는 2의 n(자리수)제곱으로 연결되므로, 왼쪽으로 1칸 옮길 때마다 비트가 표현하는 값에 2가 곱해진다. <br> 반대로 오른쪽으로 비트를 1칸 옮길 때마다 비트가 표현하는 값에 1/2이 곱해진다.

1. \<< <br>
  ```
  int a = 5;    //0101
  cout << bitset<4>(a << 2) << endl;   //0101에서 모든 비트가 왼쪽으로 2칸 이동
  cout << (a << 2) << endl;
  // 출력 결과 : 0100   (좌측부터 01은 소실, 우측부터 남는 자리는 0으로 채워짐)
  // 출력 결과 : 20     (5에 2^2이 곱해진 결과)
  ```

2. \>> <br>
  ```
  int a = 5;    //0101
  cout << bitset<4>(a >> 2) << endl;   //0101에서 모든 비트가 왼쪽으로 2칸 이동
  cout << (a >> 2) << endl;
  // 출력 결과 : 0100   (우측부터 01은 소실, 왼쪽부터 남는 자리는 0으로 채워짐)
  // 출력 결과 : 1     (5에 2^2이 나눠진 결과)  (5/4 => 1)
  ```

<br><br>

## 비트 논리 연산자
비트 논리 연산은 두 비트의 각 자리의 bit를 대상으로 논리 비교 연산을 수행한다.

* & (AND)<br>

```
unsigned int a = 0b0101;
unsigned int b = 0b1111;
//0 1 0 1
//1 1 1 1    
// 각 자리의 bit를 대상으로 And 연산하여 위 아래 두 비트가 1이면 1, 하나라도 1이 아니면 0

cout << bitset<4>(a & b) << endl;
cout << (a&b) << endl;
// 출력 결과 : 0101
// 출력 결과 : 5
```

* \| (OR)<br>

```
unsigned int a = 0b0101;
unsigned int b = 0b1111;
//0 1 0 1
//1 1 1 1    
// 각 자리의 bit를 대상으로 OR 연산하여 위 아래 두 비트가 하나라도 1이면 1, 둘 다 0이면 0

cout << bitset<4>(a | b) << endl;
cout << (a|b) << endl;
// 출력 결과 : 1111
// 출력 결과 : 15

```

* ^ (xor)<br>

```
unsigned int a = 0b0101;
unsigned int b = 0b1111;
//0 1 0 1
//1 1 1 1    
// 각 자리의 bit를 대상으로 XOR 연산하여 위 아래 두 비트가 같으면 0, 다르면 1

cout << bitset<4>(a ^ b) << endl;
cout << (a^b) << endl;
// 출력 결과 : 1010
// 출력 결과 : 10
```

<br><br>

## 비트 연산의 활용
위와 같은 비트 연산이 어떻게 활용될까?<br>
게임 프로그래밍을 예시로 비트 플래그와 비트 마스크를 활용해보자
<br>


### 비트 플래그, 비트 마스크
게임 캐릭터에 대해, 각 상태 이상을 나타내는 boolean 변수를 유지한다고 가정해보자 <br> 만약 상태 이상 종류가 20개가 넘어가면 20개가 넘는 boolean 변수를 유지해야한다.<br>
위 방식으로 개발을 하면 코드가 지저분하고 당연히 유지보수하기 어려울 것이다! 또한 1bit로 표현할 수 있는 boolean은 1byte(8bit)의 크기를 할당받는다.. -> **메모리 낭비**

* 따라서 상태 이상을 여러 개의 boolean변수에 유지하는 것이 아니라 byte 단위 변수 하나를 할당받은 후, 해당 변수를 구성하는 비트에 0과 1로 상태 이상을 유지하면 된다! 

<br>

이렇게 유지한 비트 플래그는 비트 마스크를 이용하여 특정 비트가 켜져있는지(어떤 상태 이상에 걸렸는지)를 쉽게 알 수 있다. 
<br>

아래 코드는 상태 이상을 나타내는 비트 플래그와 비트 마스크의 예시이다.
```
// 0b0000 <- 왼쪽부터 첫번째 비트는 기절, 두번째 비트는 중독, 세번째 비트는 변이, 네번째 비트는 공중부양을 나타내도록 설계

// 각 상태 이상을 나타내는 비트를 상수로 설정
const char STUN = 0b1000; // 기절
const char POISION = 0b0100;  // 중독
const char TRANSITION = 0b0010; // 변이
const char LEVITATION = 0b0001; // 공중부양

char flag = 0b0000; // 캐릭터 상태를 나타내는 flag

flag = flag | STUN;   // OR 비트 논리 연산을 이용하여 캐릭터에게 '기절' 상태를 추가하는 코드 
cout << bitset<4>(flag | STUN) << endl;

// 비트 마스크 사용 예시
bool isStun = (flag & STUN);
if(isStun)
    cout << "캐릭터가 기절했습니다." << endl;
else
    cout << "캐릭터가 기절하지 않았습니다." << endl;

// 출력 결과
// 1000
// 캐릭터가 기절했습니다.
```


<br><br>


