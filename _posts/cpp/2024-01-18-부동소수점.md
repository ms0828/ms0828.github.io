---
title: "0.1 + 0.2 == 0.3 => False?"
excerpt: "부동소수점 - 컴퓨터는 실수를 어떻게 표현할까"

categories:
  - C/C++
tags:
  - [c,cpp]

permalink: /categories/c/floating_point

toc: true
toc_sticky: true

date: 2024-01-18
last_modified_at: 2024-01-18
---
소수를 이용해 연산을 하다 보면, 가끔 예기치 못한 결과가 발생한다. <br>

![소수 연산의 잘못된 예](/assets\images\posts_img\cpp\CalculateFloating.png)

<br> 왜 이런 결과가 발생하는 것일까?

컴퓨터는 숫자를 2진수로 표현하므로, float(4byte), double(8byte)와 같이 할당된 메모리 크기에 bit를 사용해서 숫자를 저장해야 한다. <br>
그런데 특정 소수는 2진수로 표현하면 특정 구간이 무한반복된다. 
(0.3을 2진수로 표현하면 0.0100110011...) <br>따라서 컴퓨터는 한정된 메모리 공간에 실수를 100% 완전히 나타내지 못한다!
* 결론은 컴퓨터는 실수를 가장 가까운 근사값으로 저장할 수 밖에 없다는 것

<br>
<br>

## 컴퓨터가 실수를 표현하는 방법
위처럼 컴퓨터는 실수를 가장 가까운 근사값으로 표현하기 위해 2가지 방법을 사용한다.
1. 고정소수점
2. 부동소수점

<br>
고정 소수점은 정수 부분과 소수 부분을 고정적으로 공간을 분리해서 나타내는 방법을 말한다. 예를들어, 34.567 같은 경우 정수 부분 34(00100010)과 소수 부분567(1001000100...)를 구분해서 저장한다.(괄호 안에 값은 2진수로 변환한 값)<br>
그런데 이 방법은 주어진 메모리 공간에 표현할 수 있는 값의 범위가 굉장히 작다는 단점을 가진다. 즉, 메모리 공간 대비 값의 표현이 비효율적이다.(메모리는 최대한 적은 공간을 사용해야 좋지 않을까!)

<br>
부동 소수점은 소수점의 위치를 고정해서 저장하지 않고 부호를 나타내는 부호 비트와 소수를 나타내는 가수(유효숫자)비트, 지수(소수점 위치)비트를 사용해서 소수를 표현하는 방식이다.

> 이는 IEEE 754(표준 부동소수점 방식)에서 제공되는 형식!

<br>

## 부동 소수점 표현 (IEEE 754)
34.567를 2진수로 표현하면 
~~00~~100010.1001000100...이 되는데 맨 왼쪽 1뒤로 소수점을 옮기고, 원래 소수점을 나타내기 위한 2의 n제곱을 곱한 값으로 표현하면 다음과 같다. <br>
* 1.000101001000100... x 2^5  (여기서 5가 지수이다!)
> 위와 같은 형식으로 변환하는 것을 정규화 과정이라고 한다.

다음은 IEEE 754 형식에 맞춰 실수를 저장한다.

![](/assets\images\posts_img\cpp\IEEE_FloatingPoint.png)

> 참고사항 - 4바이트(32bit)를 사용하여 저장하는 방식을 단정도, 8바이트(64bit)를 사용하여 저장하는 방식을 배정도라고 함. 위 사진은 단정도 기준!

* 부호 비트(1bit)에 양수이면 0, 음수이면 1을 저장
* 위의 1.00010100... x 2^5 경우 5에 +127을 더하여 132(10000100)를 지수 비트(8bit)에 저장 (+127은 IEEE 754 방식에서 지정한 bias 값으로, 이는 지수가 음수가 되는 것을 대비한 전략이다.)
* 소수점 뒤의 숫자를 가수 비트(23bit)에 앞에서 부터 저장 (남는 부분은 0으로 채운다.)

결과로 0(부호 비트) 10000100(지수 비트) 000101001000100...(가수 비트)에 저장되게 된다. (따라서 32bit 공간에 실수의 가장 가까운 근사값이 표현되었다!)
* 01000010000010100100010010011100

<br><br>

**위처럼, 부동 소수점 방식으로 표현된 값을 10진수로 변환하면 34.5670013427734375 라는 값이 나온다. 결국 컴퓨터는 특정 실수를 100% 정확한 값으로 표현할 수 없는 것이다. <br> 따라서 이 글의 제목 0.1 + 0.2 == 0.3이 False가 나오는 이유를 설명할 수 있다.**



